#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    IRsensorM,      sensorReflection)
#pragma config(Sensor, dgtl1,  Button_R,       sensorTouch)
#pragma config(Sensor, dgtl2,  start_button,   sensorTouch)
#pragma config(Sensor, dgtl3,  USS,            sensorSONAR_raw)
#pragma config(Sensor, dgtl5,  Button_L,       sensorTouch)
#pragma config(Sensor, dgtl6,  Button_W,       sensorNone)
#pragma config(Sensor, dgtl12, LED,            sensorDigitalOut)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           R_motor,       tmotorVex393_HBridge, openLoop, driveRight, encoderPort, I2C_2)
#pragma config(Motor,  port2,           A_motor,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          L_motor,       tmotorVex393_HBridge, openLoop, driveLeft, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

typedef enum {
	Initial = 0,
	Scan,
	Forward,
	Turning,
	Deliver,
	End
} T_State;

const int light_threshold = 512; 	// threshold for the IR sensor to switch between states
const int TH = 1000; 							// threshold for the Ultrasonic sensor

// code to set the bool state of the buttons
bool SB_state = false;
bool LB_state = false;
bool RB_state = false;

void button(){
	if(SensorValue(start_button) && !SB_state){
		SB_state = true;
	}
	if(SensorValue(Button_R) && !RB_state){
		RB_state = true;
	}
	if(SensorValue(Button_L) && !LB_state){
		LB_state = true;
	}
}

// Perform processing of measurements.
// Should be called with rate of at least 20 Hertz for proper detection of puck.
// I made this a function with one parameter, the IR sensor that that booleen value is wanted
int monitorLight(){

	static int minLevelIR = 4096;	// Minimum light level seen by IR sensor 1
	static int maxLevelIR = 0;			// Maximum light level seen by IR sensor 1
	static int diffLevelIR = 0;		// Delta between maximum and minimum seen in last 0.1 seconds

	int lightLevel = SensorValue[IRsensorM];
	//bool returnValue;

	// Check if 100 msecs have elapsed.
	if ( time1[T1] > 100 )  {

		// 100 msecs have elapsed.  Compute delta of light level.
		diffLevelIR = maxLevelIR - minLevelIR;

		// Reset calculation for next 100 msecs.
		maxLevelIR = 0;
		minLevelIR = 4096;
		clearTimer(T1);

		} else {

		// Check for new minimum/maximum light levels.
		if ( lightLevel < minLevelIR ) {
			minLevelIR = lightLevel;
			} else if ( lightLevel > maxLevelIR ) {
			maxLevelIR = lightLevel;
		}
	}

	// Check if light level difference over threshold.
	/*if ( diffLevelIR > light_threshold ) {
	returnValue = true;
	} else {
	returnValue = false;

	}*/

	return(diffLevelIR);
} // end of IR sensor code


// turns the robot in the direction and amount specified
void turn(int direction, int amount){
	continue;
}


// makes the robot go straight in the direction and amount specified
void straight(int direction, int amount){
	continue;
}

// end of pre-processor material


// beginning of main body

// start of task main
task main(){

	T_State robot_state = Initial;

	while(true){

		button();
		resetMotorEncoder(L_motor);
		resetMotorEncoder(R_motor);
		int IRval = monitorLight();

		switch (robot_state){
		case Initial:

			break;

		case Scan:

			break;

		case Forward :

			break;

		case Turning:

			break;

		case Deliver:

			break;

		case End:

			break;
		}

	} // end while(true) loop

}// end task main
